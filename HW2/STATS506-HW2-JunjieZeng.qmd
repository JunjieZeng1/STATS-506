---
title: "STATS506-HW2-JunjieZeng"
author: "JunjieZeng"
format: html
editor: visual
---

# STATS506 Problem Set #2

## Repository

https://github.com/JunjieZeng1/STATS-506.git

## Problem 1 Dice Game

### a

Version 1

```{r}
#' Function to simulate dice game using a loop
#'
#' @param x a numeric number, the number of dice to roll
#' @return Total winnings
play_dice_loop <- function(x){
  net_win = 0

  for (i in 1:x){
    roll <- sample(c(1:6), size = 1)
    if (roll %in% c(3, 5)){
      net_win = net_win + 2 * roll - 2
    }
    else{
      net_win = net_win - 2
    }
  }
  return(net_win)
}
```

Version2

```{r}
#' Function to simulate dice game using built-in R vectorized functions
#'
#' @param x a numeric number, the number of dice to roll
#' @return Total winnings
play_dice_vec <- function(x){
  roll <- sample(c(1:6), x, replace = TRUE)
  games <- ifelse(roll %in% c(3, 5), roll * 2 - 2 , -2)
  net_win = sum(games)
  return(net_win)
}
```

Version3

```{r}
#' Function to simulate dice game using table()
#'
#' @param x a numeric number, the number of dice to roll
#' @return Total winnings
play_dice_tb <- function(x){
  net_win = 0
  roll <- sample(c(1:6), x, replace = TRUE)
  table_roll <- table(roll)
  if ("3" %in% names(table_roll)){
    num_3 = as.integer(table_roll["3"])
    net_win = net_win +  2 * 3 * num_3
  }
  
  if ("5" %in% names(table_roll)){
    num_5 = as.integer(table_roll["5"])
    net_win = net_win +  2 * 5 * num_5
  }
  
  net_win = net_win - 2 * x
  
  return(net_win)
}
```

Version4

```{r}
#' Function to simulate dice game using apply
#'
#' @param x a numeric number, the number of dice to roll
#' @return Total winnings

play_dice_apply <- function(x){
  roll <- sample(c(1:6), x, replace = TRUE)
  games <- sapply(roll, function(x){
    if (x %in% c(3, 5)){
      num = x * 2 - 2
      return(num)
    }
    else{
      return(-2)
    }
  })
  return(sum(games))
}
```

### b

```{r}
for (i in c(3, 3000)){
  print(paste('Using loop with', i, 'rolls:', play_dice_loop(i)))
  print(paste('Using vectorized function with', i, 'rolls:', play_dice_vec(i)))
  print(paste('Using table with', i, 'rolls:', play_dice_tb(i)))
  print(paste('Using sapply with', i, 'rolls:', play_dice_apply(i)))
}
```

### c

```{r}
for (i in c(3, 3000)){
  set.seed(506)
  print(paste('Using loop with', i, 'rolls:', play_dice_loop(i)))
  set.seed(506)
  print(paste('Using vectorized function with', i, 'rolls:', play_dice_vec(i)))
  set.seed(506)
  print(paste('Using table with', i, 'rolls:', play_dice_tb(i)))
  set.seed(506)
  print(paste('Using sapply with', i, 'rolls:', play_dice_apply(i)))
}
```

We see that all the four versions give the same result for a given number of rolls. So those four versions are the same.

### d
```{r}
library(microbenchmark)
```
```{r}
microbenchmark(play_dice_loop(1000), play_dice_vec(1000), play_dice_tb(1000), play_dice_apply(1000))
```
```{r}
microbenchmark(play_dice_loop(100000), play_dice_vec(100000), play_dice_tb(100000), play_dice_apply(100000))
```
The first table with input(1000) has unit in microseconds.The second table with input(100000) has unit in milliseconds. 
In both tables, we see the speed rank as follows: play_dice_tb > play_dice_vec >> play_dice_apply >> play_dice_loop. This is especially significant when input is large. 

### e
```{r}
set.seed(506)
play_dice_tb(100000)
```
Based on a Monte Carlo simulation with 100000 runs, the final net gain is 67796, suggesting this is a unfair game. 


